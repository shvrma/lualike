module;

#include <cstdint>
#include <format>
#include <ranges>
#include <sstream>
#include <variant>

#include "frozen/string.h"
#include "frozen/unordered_map.h"

export module lualike.token;

export import lualike.value;

namespace value = lualike::value;

export namespace lualike::token {

enum class TokenKind : uint8_t {
  kNone,

  kName,  // Same as identifier
  kLiteral,

  kKeywordAnd,
  kKeywordBreak,
  kKeywordDo,
  kKeywordElse,
  kKeywordElseif,
  kKeywordEnd,
  kKeywordFalse,
  kKeywordFor,
  kKeywordFunction,
  kKeywordGoto,
  kKeywordIf,
  kKeywordIn,
  kKeywordLocal,
  kKeywordNil,
  kKeywordNot,
  kKeywordOr,
  kKeywordRepeat,
  kKeywordReturn,
  kKeywordThen,
  kKeywordTrue,
  kKeywordUntil,
  kKeywordWhile,

  kOtherPlus,
  kOtherMinus,
  kOtherAsterisk,
  kOtherSlash,
  kOtherPercent,
  kOtherCaret,  // ^
  kOtherDoubleSlash,
  kOtherDoubleEqual,
  kOtherTildeEqual,  // ~=
  kOtherLessThanEqual,
  kOtherGreaterThanEqual,
  kOtherLessThan,
  kOtherGreaterThan,
  kOtherEqual,
  kOtherLeftParenthesis,
  kOtherRightParenthesis,
  kOtherLeftFigureBracket,
  kOtherRightFigureBracket,
  kOtherLeftSquareBracket,
  kOtherRightSquareBracket,
  kOtherSemicolon,
  kOtherColon,
  kOtherComma,
  kOtherDot,
};

struct Token {
  TokenKind token_kind;
  std::variant<std::monostate, std::string, value::LualikeValue> token_data;

  bool operator==(const Token &rhs) const = default;

  std::string ToString() const;
};

constexpr auto kKeywordsMap =
    frozen::make_unordered_map<frozen::string, TokenKind>({
        {"and", TokenKind::kKeywordAnd},
        {"break", TokenKind::kKeywordBreak},
        {"do", TokenKind::kKeywordDo},
        {"else", TokenKind::kKeywordElse},
        {"elseif", TokenKind::kKeywordElseif},
        {"end", TokenKind::kKeywordEnd},
        {"false", TokenKind::kKeywordFalse},
        {"for", TokenKind::kKeywordFor},
        {"function", TokenKind::kKeywordFunction},
        {"goto", TokenKind::kKeywordGoto},
        {"if", TokenKind::kKeywordIf},
        {"in", TokenKind::kKeywordIn},
        {"local", TokenKind::kKeywordLocal},
        {"nil", TokenKind::kKeywordNil},
        {"not", TokenKind::kKeywordNot},
        {"or", TokenKind::kKeywordOr},
        {"repeat", TokenKind::kKeywordRepeat},
        {"return", TokenKind::kKeywordReturn},
        {"then", TokenKind::kKeywordThen},
        {"true", TokenKind::kKeywordTrue},
        {"until", TokenKind::kKeywordUntil},
        {"while", TokenKind::kKeywordWhile},
    });

constexpr auto kOtherTokensMap =
    frozen::make_unordered_map<frozen::string, TokenKind>({
        {"+", TokenKind::kOtherPlus},
        {"-", TokenKind::kOtherMinus},
        {"*", TokenKind::kOtherAsterisk},
        {"/", TokenKind::kOtherSlash},
        {"%", TokenKind::kOtherPercent},
        {"^", TokenKind::kOtherCaret},
        {"//", TokenKind::kOtherDoubleSlash},
        {"==", TokenKind::kOtherDoubleEqual},
        {"~=", TokenKind::kOtherTildeEqual},
        {"<=", TokenKind::kOtherLessThanEqual},
        {">=", TokenKind::kOtherGreaterThanEqual},
        {"<", TokenKind::kOtherLessThan},
        {">", TokenKind::kOtherGreaterThan},
        {"=", TokenKind::kOtherEqual},
        {"(", TokenKind::kOtherLeftParenthesis},
        {")", TokenKind::kOtherRightParenthesis},
        {"{", TokenKind::kOtherLeftFigureBracket},
        {"}", TokenKind::kOtherRightFigureBracket},
        {"[", TokenKind::kOtherLeftSquareBracket},
        {"]", TokenKind::kOtherRightSquareBracket},
        {";", TokenKind::kOtherSemicolon},
        {":", TokenKind::kOtherColon},
        {",", TokenKind::kOtherComma},
        {".", TokenKind::kOtherDot},
    });

std::string Token::ToString() const {
  std::ostringstream output{};

  const auto token_kind_name = [this]() -> std::string {
    switch (Token::token_kind) {
      case TokenKind::kNone:
        return "none";

      case TokenKind::kName:
        return "name";

      case TokenKind::kLiteral:
        return "literal";

      default:
        break;
    }

    if (const auto &find_result =
            std::ranges::find_if(kKeywordsMap,
                                 [this](const auto &pair) {
                                   return pair.second == Token::token_kind;
                                 });
        find_result != std::ranges::cend(kKeywordsMap)) {
      return {find_result->first.data()};
    }

    if (const auto &find_result =
            std::ranges::find_if(kOtherTokensMap,
                                 [this](const auto &pair) {
                                   return pair.second == Token::token_kind;
                                 });
        find_result != std::ranges::cend(kOtherTokensMap)) {
      return std::format("other token <<< {} >>>", find_result->first.data());
    }

    return "unknown";
  }();

  output << token_kind_name << ' ';

  std::visit(
      [&output, this](auto &&value) {
        using T = std::decay_t<decltype(value)>;

        if constexpr (std::is_same<T, std::string>()) {
          output << "<<< " << value << " >>>";
        }

        else if constexpr (std::is_same<T, value::LualikeValue>()) {
          output << "<<< " << value.ToString() << " >>>";
        }
      },
      Token::token_data);

  return output.str();
}

}  // namespace lualike::token
