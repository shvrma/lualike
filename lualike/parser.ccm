module;

#include <expected>
#include <format>
#include <generator>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

export module lualike.parser;

export import lualike.value;
export import lualike.ast;
import lualike.lexer;

using lualike::ast::BinaryOperator;
using lualike::token::Token;
using lualike::token::TokenKind;
using lualike::value::LualikeValue;

export namespace lualike::parser {

enum class ParserErrKind : uint8_t {
  kUnexpectedToken,
  kExpectedExpression,
  kExpectedIdentifier,
  kInternalError,
};

struct ParserErr : std::exception {
  ParserErrKind kind;
  std::variant<std::monostate, std::exception_ptr> error;
  mutable std::string message_;  // store generated message

  explicit ParserErr(ParserErrKind kind)
      : kind(kind), error(std::monostate{}) {}

  explicit ParserErr(const std::exception& /*unused*/) noexcept
      : kind(ParserErrKind::kInternalError), error(std::current_exception()) {}

  const char* what() const noexcept override {
    switch (kind) {
      case ParserErrKind::kUnexpectedToken:
        return "Unexpected token encountered";

      case ParserErrKind::kExpectedExpression:
        return "Expected an expression";

      case ParserErrKind::kExpectedIdentifier:
        return "Expected an identifier";

      case ParserErrKind::kInternalError:
        try {
          std::rethrow_exception(std::get<std::exception_ptr>(error));
        } catch (const std::exception& e) {
          message_ = std::format("Internal parser error: {}", e.what());
          return message_.c_str();
        }

        return "Internal parser error";

      default:
        return "Unknown parser error";
    }
  }
};

template <std::ranges::view InputT>
class Parser {
 private:
  using TokensR = std::generator<Token>;

  TokensR tokens_;
  std::ranges::iterator_t<TokensR> iter_;

  bool IsEOF() const;
  const Token& Peek() const;
  Token Advance();
  Token Consume(TokenKind kind);
  bool Match(TokenKind kind);

  ast::Statement ParseStmt();
  ast::ReturnStatement ParseRetStmt();
  ast::VariableDeclaration ParseVarDecl(bool is_local);
  ast::IfStatement ParseIfStmt();
  ast::Block ParseBlock(std::initializer_list<TokenKind> end_tokens);
  ast::ExpressionStatement ParseExprStmt();
  ast::Expression ParseExpr(int min_precedence = 0);
  ast::Expression ParsePrimExpr();

 public:
  explicit Parser(InputT input)
      : tokens_(lexer::ReadTokens(input)), iter_(tokens_.begin()) {};

  ast::Program Parse();
};

template <std::ranges::view InputT>
std::expected<ast::Program, ParserErr> Parse(InputT input) noexcept {
  try {
    Parser<InputT> parser(input);
    return parser.Parse();
  } catch (const ParserErr& err) {
    return std::unexpected(err);
  } catch (const std::exception& e) {
    return std::unexpected(ParserErr(e));
  } catch (...) {
    return std::unexpected(ParserErr(ParserErrKind::kInternalError));
  }
}

}  // namespace lualike::parser

// module :private;

namespace lualike::parser {

static const std::unordered_map<TokenKind, int> kBinOpsPrecedences = {
    {TokenKind::kKeywordOr, 1},          {TokenKind::kKeywordAnd, 2},
    {TokenKind::kOtherLessThan, 3},      {TokenKind::kOtherGreaterThan, 3},
    {TokenKind::kOtherLessThanEqual, 3}, {TokenKind::kOtherGreaterThanEqual, 3},
    {TokenKind::kOtherTildeEqual, 3},    {TokenKind::kOtherDoubleEqual, 3},
    {TokenKind::kOtherPlus, 9},          {TokenKind::kOtherMinus, 9},
    {TokenKind::kOtherAsterisk, 10},     {TokenKind::kOtherSlash, 10},
    {TokenKind::kOtherDoubleSlash, 10},  {TokenKind::kOtherPercent, 10},
    {TokenKind::kOtherCaret, 11},
};

static const std::unordered_map<TokenKind, ast::BinaryOperator> kTokenToBinOp =
    {
        {TokenKind::kKeywordOr, ast::BinaryOperator::kOr},
        {TokenKind::kKeywordAnd, ast::BinaryOperator::kAnd},
        {TokenKind::kOtherLessThan, ast::BinaryOperator::kLessThan},
        {TokenKind::kOtherGreaterThan, ast::BinaryOperator::kGreaterThan},
        {TokenKind::kOtherLessThanEqual, ast::BinaryOperator::kLessThanEqual},
        {TokenKind::kOtherGreaterThanEqual,
         ast::BinaryOperator::kGreaterThanEqual},
        {TokenKind::kOtherTildeEqual, ast::BinaryOperator::kNotEqual},
        {TokenKind::kOtherDoubleEqual, ast::BinaryOperator::kEqual},
        {TokenKind::kOtherPlus, ast::BinaryOperator::kAdd},
        {TokenKind::kOtherMinus, ast::BinaryOperator::kSubtract},
        {TokenKind::kOtherAsterisk, ast::BinaryOperator::kMultiply},
        {TokenKind::kOtherSlash, ast::BinaryOperator::kDivide},
        {TokenKind::kOtherDoubleSlash, ast::BinaryOperator::kFloorDivide},
        {TokenKind::kOtherPercent, ast::BinaryOperator::kModulo},
        {TokenKind::kOtherCaret, ast::BinaryOperator::kPower},
};

static int GetPrec(TokenKind kind) {
  if (kBinOpsPrecedences.contains(kind)) {
    return kBinOpsPrecedences.at(kind);
  }
  return -1;
}

LualikeValue TokenToValue(const Token& token) {
  switch (token.token_kind) {
    case TokenKind::kStringLiteral: {
      std::string_view data = token.token_data.value();
      // Remove quotes
      return {std::string(data.substr(1, data.length() - 2))};
    }

    case TokenKind::kIntLiteral: {
      try {
        return {std::stoi(std::string(token.token_data.value()))};
      } catch (const std::exception&) {
        throw ParserErr(ParserErrKind::kInternalError);
      }
    }

    case TokenKind::kFloatLiteral: {
      try {
        return {std::stod(std::string(token.token_data.value()))};
      } catch (const std::exception&) {
        // This should ideally not be reached if the lexer is correct
        throw ParserErr(ParserErrKind::kInternalError);
      }
    }

    case TokenKind::kName:
      return {std::string(token.token_data.value())};

    case TokenKind::kKeywordTrue:
      return {true};

    case TokenKind::kKeywordFalse:
      return {false};

    case TokenKind::kKeywordNil:
      return {};

    default:
      throw ParserErr(ParserErrKind::kUnexpectedToken);
  }
}

template <std::ranges::view InputT>
ast::Program Parser<InputT>::Parse() {
  ast::Program program;
  auto& stmts = program.statements;

  while (!IsEOF()) {
    while (Match(TokenKind::kOtherSemicolon)) {
    }

    if (IsEOF()) {
      break;
    }

    stmts.push_back(ParseStmt());
  }

  return program;
}

template <std::ranges::view InputT>
bool Parser<InputT>::IsEOF() const {
  return iter_ == tokens_.end();
}

template <std::ranges::view InputT>
const Token& Parser<InputT>::Peek() const {
  if (IsEOF()) {
    throw ParserErr(ParserErrKind::kUnexpectedToken);
  }

  return *iter_;
}

template <std::ranges::view InputT>
Token Parser<InputT>::Advance() {
  if (IsEOF()) {
    throw ParserErr(ParserErrKind::kUnexpectedToken);
  }
  auto token = *iter_;
  ++iter_;
  return token;
}

template <std::ranges::view InputT>
Token Parser<InputT>::Consume(TokenKind kind) {
  const auto& token = Peek();
  if (token.token_kind != kind) {
    throw ParserErr(ParserErrKind::kUnexpectedToken);
  }

  return Advance();
}

template <std::ranges::view InputT>
bool Parser<InputT>::Match(TokenKind kind) {
  if (IsEOF() || Peek().token_kind != kind) {
    return false;
  }

  Advance();

  return true;
}

template <std::ranges::view InputT>
ast::Statement Parser<InputT>::ParseStmt() {
  while (Match(TokenKind::kOtherSemicolon)) {
  }

  switch (Peek().token_kind) {
    case TokenKind::kName:
      return {ParseVarDecl(false)};

    case TokenKind::kKeywordReturn:
      return {ParseRetStmt()};

    case TokenKind::kKeywordLocal:
      return {ParseVarDecl(true)};

    case TokenKind::kKeywordIf:
      return {ParseIfStmt()};

    default:
      return {ParseExprStmt()};
  }
}

template <std::ranges::view InputT>
ast::ReturnStatement Parser<InputT>::ParseRetStmt() {
  Advance();

  if (IsEOF() || Peek().token_kind == TokenKind::kOtherSemicolon) {
    return {std::nullopt};
  }

  return {ParseExpr()};
}

template <std::ranges::view InputT>
ast::VariableDeclaration Parser<InputT>::ParseVarDecl(bool is_local) {
  if (is_local) {
    Consume(TokenKind::kKeywordLocal);
  }

  auto name_token = Consume(TokenKind::kName);

  std::optional<ast::Expression> initializer;
  if (Match(TokenKind::kOtherEqual)) {
    initializer = ParseExpr();
  }

  return {std::string(name_token.token_data.value()), std::move(initializer)};
}

template <std::ranges::view InputT>
ast::IfStatement Parser<InputT>::ParseIfStmt() {
  Advance();

  auto condition = ParseExpr();

  Consume(TokenKind::kKeywordThen);
  auto then_branch = std::make_unique<ast::Block>(
      ParseBlock({TokenKind::kKeywordElse, TokenKind::kKeywordEnd}));

  std::unique_ptr<ast::Block> else_branch;
  if (Match(TokenKind::kKeywordElse)) {
    else_branch =
        std::make_unique<ast::Block>(ParseBlock({TokenKind::kKeywordEnd}));
  }

  Consume(TokenKind::kKeywordEnd);

  return {std::move(condition), std::move(then_branch), std::move(else_branch)};
}

template <std::ranges::view InputT>
ast::Block Parser<InputT>::ParseBlock(
    std::initializer_list<TokenKind> end_tokens) {
  ast::Block block;

  while (!IsEOF() &&
         std::ranges::find(end_tokens, Peek().token_kind) == end_tokens.end()) {
    while (Match(TokenKind::kOtherSemicolon)) {
    }

    if (IsEOF() ||
        std::ranges::find(end_tokens, Peek().token_kind) != end_tokens.end()) {
      break;
    }

    block.statements.push_back(ParseStmt());
  }

  return block;
}

template <std::ranges::view InputT>
ast::ExpressionStatement Parser<InputT>::ParseExprStmt() {
  return {ParseExpr()};
}

template <std::ranges::view InputT>
ast::Expression Parser<InputT>::ParseExpr(int min_precedence) {
  auto lhs = ParsePrimExpr();

  while (!IsEOF()) {
    const auto prec_it = kBinOpsPrecedences.find(Peek().token_kind);
    int precedence =
        (prec_it != kBinOpsPrecedences.end()) ? prec_it->second : -1;
    if (precedence < min_precedence) {
      break;
    }

    auto op_token = Advance();
    int next_precedence = (op_token.token_kind == TokenKind::kOtherCaret)
                              ? precedence
                              : precedence + 1;
    auto rhs = ParseExpr(next_precedence);

    lhs.node = ast::BinaryExpression{
        kTokenToBinOp.at(op_token.token_kind),
        std::make_unique<ast::Expression>(std::move(lhs)),
        std::make_unique<ast::Expression>(std::move(rhs))};
  }
  return lhs;
}

template <std::ranges::view InputT>
ast::Expression Parser<InputT>::ParsePrimExpr() {
  const auto token = Advance();

  switch (token.token_kind) {
    case TokenKind::kStringLiteral:
    case TokenKind::kIntLiteral:
    case TokenKind::kFloatLiteral:
    case TokenKind::kKeywordTrue:
    case TokenKind::kKeywordFalse:
    case TokenKind::kKeywordNil:
      return {{ast::LiteralExpression{TokenToValue(token)}}};

    case TokenKind::kName:
      return {{ast::VariableExpression{std::string(token.token_data.value())}}};

    case TokenKind::kOtherMinus:
    case TokenKind::kKeywordNot: {
      const auto unary_prec = 99;  // Higher than any binary operator
      const auto oper = (token.token_kind == TokenKind::kOtherMinus)
                            ? ast::UnaryOperator::kNegate
                            : ast::UnaryOperator::kNot;
      return {{ast::UnaryExpression{
          oper, std::make_unique<ast::Expression>(ParseExpr(unary_prec))}}};
    }

    case TokenKind::kOtherLeftParenthesis: {
      auto expr = ParseExpr();
      Consume(TokenKind::kOtherRightParenthesis);
      return expr;
    }

    default:
      throw ParserErr(ParserErrKind::kExpectedExpression);
  }
}

}  // namespace lualike::parser
