module;

#include <cstdint>
#include <exception>
#include <expected>
#include <format>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <utility>
#include <variant>

export module lualike.interpreter;

import lualike.lexer;
import lualike.parser;

using lualike::ast::BinaryOperator;
using lualike::ast::UnaryOperator;
using lualike::lexer::LexerErr;
using lualike::parser::ParserErr;
using lualike::token::Token;
using lualike::token::TokenKind;
using lualike::value::LualikeValue;

export namespace lualike::interpreter {

enum class InterpreterErrKind : uint8_t {
  kUnknownName,
  kRedeclarationOfLocalVariable,
  kInternalException,
  kSyntaxError,
  kParserError,
};

struct InterpreterErr : std::exception {
  InterpreterErrKind error_kind;
  std::variant<std::monostate, std::exception_ptr, LexerErr, ParserErr> error;
  mutable std::string message_;  // store generated message

  explicit InterpreterErr(InterpreterErrKind error_kind) noexcept
      : error_kind(error_kind) {}

  explicit InterpreterErr(const std::exception& /*unused*/) noexcept
      : error_kind(InterpreterErrKind::kInternalException),
        error(std::current_exception()) {}

  explicit InterpreterErr(const LexerErr& lexer_err) noexcept
      : error_kind(InterpreterErrKind::kSyntaxError), error(lexer_err) {}

  explicit InterpreterErr(const ParserErr& parser_err) noexcept
      : error_kind(InterpreterErrKind::kParserError), error(parser_err) {}

  const char* what() const noexcept override {
    switch (error_kind) {
      case InterpreterErrKind::kUnknownName:
        return "Unknown name encountered";

      case InterpreterErrKind::kRedeclarationOfLocalVariable:
        return "Redeclaration of local variable";

      case InterpreterErrKind::kInternalException:
        try {
          std::rethrow_exception(std::get<std::exception_ptr>(error));
        } catch (const std::exception& e) {
          message_ = std::format("Internal interpreter error: {}", e.what());
          return message_.c_str();
        }

        return "Internal interpreter error";

      case InterpreterErrKind::kSyntaxError:
        return "Syntax error in input";

      case InterpreterErrKind::kParserError:
        message_ =
            std::format("Parser error: {}", std::get<ParserErr>(error).what());
        return message_.c_str();
    }
  }
};

class Interpreter {
  using NamesT = std::unordered_map<std::string, LualikeValue>;

  NamesT local_names_;
  std::shared_ptr<NamesT> global_names_;

  static bool IsTruthy(const LualikeValue& value);

  template <typename ExprT>
  LualikeValue ExprVisitor(const ExprT& expr);
  template <typename StmtT>
  std::optional<LualikeValue> StmtVisitor(const StmtT& stmt);

  LualikeValue VisitExpression(const ast::Expression& expression);
  std::optional<LualikeValue> VisitStatement(const ast::Statement& statement);
  std::optional<LualikeValue> VisitBlock(const ast::Block& block);

  explicit Interpreter(std::shared_ptr<NamesT> global_names)
      : global_names_(std::move(global_names)) {}

 public:
  template <std::ranges::view InputT>
  friend std::expected<std::optional<LualikeValue>, InterpreterErr> Interpret(
      InputT input) noexcept;
};

template <std::ranges::view InputT>
std::expected<std::optional<LualikeValue>, InterpreterErr> Interpret(
    InputT input) noexcept {
  try {
    auto parse_result = parser::Parse(input);
    if (!parse_result) {
      return std::unexpected(InterpreterErr(parse_result.error()));
    }

    auto interpreter = Interpreter(std::make_shared<Interpreter::NamesT>());
    return interpreter.VisitBlock(parse_result.value());
  }

  catch (const InterpreterErr& err) {
    return std::unexpected(err);
  }

  catch (const lexer::LexerErr& err) {
    return std::unexpected(InterpreterErr(err));
  }

  catch (const std::exception& exception) {
    return std::unexpected(InterpreterErr(exception));
  }

  catch (...) {
    return std::unexpected(
        InterpreterErr(InterpreterErrKind::kInternalException));
  }
}

}  // namespace lualike::interpreter

//
// module :private;

namespace lualike::interpreter {

LualikeValue Interpreter::VisitExpression(const ast::Expression& expression) {
  return std::visit([this](const auto& expr) { return ExprVisitor(expr); },
                    expression.node);
}

std::optional<LualikeValue> Interpreter::VisitStatement(
    const ast::Statement& statement) {
  return std::visit([this](const auto& stmt) { return StmtVisitor(stmt); },
                    statement.node);
}

std::optional<LualikeValue> Interpreter::VisitBlock(const ast::Block& block) {
  NamesT original_locals = local_names_;
  for (const auto& statement : block.statements) {
    if (auto return_value = VisitStatement(statement)) {
      local_names_ = original_locals;
      return return_value;
    }
  }
  local_names_ = original_locals;

  return std::nullopt;
}

bool Interpreter::IsTruthy(const LualikeValue& value) {
  if (std::holds_alternative<LualikeValue::NilT>(value.inner_value)) {
    return false;
  }

  if (std::holds_alternative<LualikeValue::BoolT>(value.inner_value)) {
    return std::get<LualikeValue::BoolT>(value.inner_value);
  }

  return true;
}

template <typename ExprT>
LualikeValue Interpreter::ExprVisitor(const ExprT& expr) {
  using T = std::decay_t<decltype(expr)>;

  if constexpr (std::is_same_v<T, ast::LiteralExpression>) {
    return expr.value;
  }

  else if constexpr (std::is_same_v<T, ast::VariableExpression>) {
    if (const auto find_result = local_names_.find(expr.name);
        find_result != local_names_.end()) {
      return find_result->second;
    }

    if (const auto find_result = global_names_->find(expr.name);
        find_result != global_names_->end()) {
      return find_result->second;
    }

    throw InterpreterErr(InterpreterErrKind::kUnknownName);
  }

  else if constexpr (std::is_same_v<T, ast::UnaryExpression>) {
    auto rhs = VisitExpression(*expr.rhs);

    switch (expr.op) {
      case UnaryOperator::kNegate:
        return -rhs;
      case UnaryOperator::kNot:
        return !rhs;
      default:
        throw std::logic_error("Unimplemented unary operator");
    }
  }

  else if constexpr (std::is_same_v<T, ast::BinaryExpression>) {
    auto lhs = VisitExpression(*expr.lhs);

    if (expr.op == BinaryOperator::kAnd) {
      return IsTruthy(lhs) ? VisitExpression(*expr.rhs) : lhs;
    }
    if (expr.op == BinaryOperator::kOr) {
      return IsTruthy(lhs) ? lhs : VisitExpression(*expr.rhs);
    }

    auto rhs = VisitExpression(*expr.rhs);

    switch (expr.op) {
      case BinaryOperator::kAdd:
        return lhs + rhs;

      case BinaryOperator::kSubtract:
        return lhs - rhs;

      case BinaryOperator::kMultiply:
        return lhs * rhs;

      case BinaryOperator::kDivide:
        return lhs / rhs;

      case BinaryOperator::kFloorDivide:
        lhs.FloorDivideAndAssign(rhs);
        return lhs;

      case BinaryOperator::kModulo:
        return lhs % rhs;

      case BinaryOperator::kPower:
        lhs.ExponentiateAndAssign(rhs);
        return lhs;

      case BinaryOperator::kEqual:
        return {lhs == rhs};

      case BinaryOperator::kNotEqual:
        return {lhs != rhs};

      case BinaryOperator::kLessThan:
        return {lhs < rhs};

      case BinaryOperator::kLessThanEqual:
        return {lhs <= rhs};

      case BinaryOperator::kGreaterThan:
        return {lhs > rhs};

      case BinaryOperator::kGreaterThanEqual:
        return {lhs >= rhs};

      default:
        throw std::logic_error("Unimplemented binary operator");
    }
  }

  else {
    throw std::logic_error("Unimplemented expression type");
  }
}

template <typename StmtT>
std::optional<LualikeValue> Interpreter::StmtVisitor(const StmtT& stmt) {
  using T = std::decay_t<decltype(stmt)>;

  if constexpr (std::is_same_v<T, ast::VariableDeclaration>) {
    LualikeValue value;  // nil by default
    if (stmt.initializer) {
      value = VisitExpression(stmt.initializer.value());
    }
    const auto [_iter, was_successful] =
        local_names_.try_emplace(stmt.name, value);
    if (!was_successful) {
      throw InterpreterErr(InterpreterErrKind::kRedeclarationOfLocalVariable);
    }
  }

  else if constexpr (std::is_same_v<T, ast::Assignment>) {
    auto value = VisitExpression(stmt.value);

    if (local_names_.contains(stmt.variable.name)) {
      local_names_.at(stmt.variable.name) = value;
    } else {
      // Assuming assignment to an undeclared variable goes to globals.
      // You might want to check if it exists in globals first or
      // throw an error.
      global_names_->insert_or_assign(stmt.variable.name, value);
    }
  }

  else if constexpr (std::is_same_v<T, ast::IfStatement>) {
    auto condition = VisitExpression(stmt.condition);

    if (IsTruthy(condition)) {
      return VisitBlock(*stmt.then_branch);
    }

    if (stmt.else_branch) {
      return VisitBlock(*stmt.else_branch);
    }
  }

  else if constexpr (std::is_same_v<T, ast::ReturnStatement>) {
    if (stmt.expression.has_value()) {
      return VisitExpression(stmt.expression.value());
    }

    return std::nullopt;
  }

  else if constexpr (std::is_same_v<T, ast::ExpressionStatement>) {
    VisitExpression(stmt.expression);
  }

  return std::nullopt;
}

}  // namespace lualike::interpreter
